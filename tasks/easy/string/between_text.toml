level             = "easy"
name              = "between_text"
tags              = ["training", "strings"]
time_to_solve_sec = 300

description_en = """
Write a function that, given a string `text` and two strings `left` and `right`, returns the substring of `text` that lies between `left` and `right`. If `text` does not contain such a substring, return an empty string.
"""

description_ru = """
Напишите функцию, которая по строке `text` и двум строкам `left` и `right` возвращает подстроку из `text`, расположенную между `left` и `right`. Если такой подстроки нет, верните пустую строку.
"""

solution = """
import re

def solution(text: str, left: str, right: str) -> str:
    m = re.search(re.escape(left) + r"(.*)" + re.escape(right), text)
    return m.group(1) if m else ""
"""

examples = """
solution("xonix", "x", "x") == "oni"
solution("no markers here", "[", "]") == ""
solution("<a>foo</a>", "<a>", "</a>") == "foo"
solution("this is 'text'", "'", "'") == "text"
"""

[[input_signature]]
argument_name = "text"
[input_signature.type]
name = "string"

[[input_signature]]
argument_name = "left"
[input_signature.type]
name = "string"

[[input_signature]]
argument_name = "right"
[input_signature.type]
name = "string"

[output_signature.type]
name = "string"

[[asserts]]
arguments = ["<a>foo</a>", "<a>", "</a>"]
comment   = "Simple HTML-like tag extraction"
expected  = "foo"

[[asserts]]
arguments = ["this is 'text'", "'", "'"]
comment   = "Substring between single quotes"
expected  = "text"

[[asserts]]
arguments = ["xonix", "x", "x"]
comment   = "Same markers on both sides"
expected  = "oni"

[[asserts]]
arguments = ["www.google.com", "www.", ".com"]
comment   = "Domain name between prefix and suffix"
expected  = "google"

[[asserts]]
arguments = ["oh wow such example", "oh", "such"]
comment   = "Substring with spaces preserved"
expected  = " wow "

[[asserts]]
arguments = ["start middle end", "start", "end"]
comment   = "Classic left and right markers around the middle"
expected  = " middle "

[[asserts]]
arguments = ["[tag]content[/tag]", "[tag]", "[/tag]"]
comment   = "XML-like tag content"
expected  = "content"

[[asserts]]
arguments = ["(secret)", "(", ")"]
comment   = "Markers are parentheses"
expected  = "secret"

[[asserts]]
arguments = ["left middle right", "left ", " right"]
comment   = "Markers include spaces"
expected  = "middle"

[[asserts]]
arguments = ["log::value::end", "log::", "::end"]
comment   = "Colon-based markers"
expected  = "value"

[[asserts]]
arguments = ["id:12345;status:ok", "id:", ";status"]
comment   = "Numeric value between markers"
expected  = "12345"

[[asserts]]
arguments = ["hello [world]!", "[", "]"]
comment   = "Simple bracketed word"
expected  = "world"

[[asserts]]
arguments = ["aaabbb", "aaa", "bbb"]
comment   = "Empty substring between adjacent markers"
expected  = ""

[[asserts]]
arguments = ["xxmiddleyy", "xx", "yy"]
comment   = "Markers made of repeated characters"
expected  = "middle"

[[asserts]]
arguments = ["prefix-<inside>-suffix", "-<", ">-"]
comment   = "Markers overlap with angle brackets and dashes"
expected  = "inside"

[[asserts]]
arguments = ["Price: $100; tax included", "$", ";"]
comment   = "Currency value between special character and semicolon"
expected  = "100"

[[asserts]]
arguments = ["2025[year]", "2025[", "]"]
comment   = "Marker includes digits and bracket"
expected  = "year"

[[asserts]]
arguments = ["path/to/file.txt", "path/", ".txt"]
comment   = "Substring between path prefix and extension"
expected  = "to/file"

[[asserts]]
arguments = ["begin<inner>outer</inner>end", "<inner>", "</inner>"]
comment   = "Nested tag-like markers"
expected  = "outer"

[[asserts]]
arguments = ["no markers here", "[", "]"]
comment   = "No left or right marker present"
expected  = ""

[[asserts]]
arguments = ["[start only", "[", "]"]
comment   = "Left marker present, right marker missing"
expected  = ""

[[asserts]]
arguments = ["finish then start", "start", "finish"]
comment   = "Left marker occurs after right marker"
expected  = ""

[[asserts]]
arguments = ["abc123abc", "abc", "abc"]
comment   = "Same multi-character markers at both sides"
expected  = "123"

[[asserts]]
arguments = ["Key:VALUE:key", "Key:", ":key"]
comment   = "Case-sensitive markers"
expected  = "VALUE"

[[asserts]]
arguments = ["a--b--c--d", "a--", "--c"]
comment   = "Markers with dashes, short middle"
expected  = "b"

[[asserts]]
arguments = ["{{name}} is cool", "{{", "}}"]
comment   = "Template-like double-brace markers"
expected  = "name"

[[asserts]]
arguments = ["<<data>>", "<<", ">>"]
comment   = "Double angle-bracket markers"
expected  = "data"

[[asserts]]
arguments = ["head [ignore] body [take] tail", "body [", "] tail"]
comment   = "Markers anchored around a specific segment"
expected  = "take"

[[asserts]]
arguments = ["token=ABC123&end", "token=", "&end"]
comment   = "Parameter value between name and terminator"
expected  = "ABC123"

[[asserts]]
arguments = ["outer(inner[deep]inner)outer", "inner[", "]inner"]
comment   = "Substring between asymmetric markers inside the text"
expected  = "deep"
