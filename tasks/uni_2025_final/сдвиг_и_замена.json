{
  "asserts": [
    {
      "arguments": ["mknk", "abac"],
      "expected": 1
    },
    {
      "arguments": ["kmkn", "abac"],
      "expected": 0
    },
    {
      "arguments": ["kkkn", "abac"],
      "expected": -1
    },
    {
      "arguments": ["hwynjbwijylowhnnnnii", "ehhcfbejdfhjbakfceee"],
      "expected": 3
    },
    {
      "arguments": ["csttsnvrftruucwucub", "ebbacbabdafggfhiekg"],
      "expected": 9
    },
    {
      "arguments": ["gmttfsgms", "aficficgg"],
      "expected": 5
    },
    {
      "arguments": ["dpnpy", "gkbgc"],
      "expected": 2
    },
    {
      "arguments": ["hpdvic", "abcabc"],
      "expected": -1
    },
    {
      "arguments": ["abcabc", "kfeabf"],
      "expected": -1
    },
    {
      "arguments": ["cmdcmdmarmycoop", "fkdfbhccahfihfi"],
      "expected": 9
    },
    {
      "arguments": ["isgglvoo", "cebddhkc"],
      "expected": 1
    },
    {
      "arguments": ["haphxpuuvath", "edbekkaicddi"],
      "expected": 10
    },
    {
      "arguments": ["kqko", "gfgk"],
      "expected": 0
    },
    {
      "arguments": ["ttjzzjuzz", "bgcbbiigb"],
      "expected": 5
    },
    {
      "arguments": ["waobkweeaztnkowazzke", "hjfgiibedafhgbeefigb"],
      "expected": 18
    },
    {
      "arguments": ["huuu", "cacc"],
      "expected": 1
    },
    {
      "arguments": ["uzrlyq", "fdcjga"],
      "expected": 0
    },
    {
      "arguments": ["tsojmpvtjbsmzxcjss", "dgjbfkhdacifhhbhef"],
      "expected": 14
    },
    {
      "arguments": ["yqsyxlssn", "gbbkafbad"],
      "expected": 4
    },
    {
      "arguments": ["cpprddjcqccjclgdolpr", "gebdjekfgkkfddhgcggh"],
      "expected": 8
    },
    {
      "arguments": ["llyfgdebcybb", "fdbijciieech"],
      "expected": 8
    },
    {
      "arguments": ["zhmewkhkpmbbzejzpeh", "cdekiijagjeacjckabd"],
      "expected": 13
    },
    {
      "arguments": ["rsjwjp", "gafegj"],
      "expected": 2
    },
    {
      "arguments": ["arxb", "beji"],
      "expected": 0
    },
    {
      "arguments": ["uuyjdjynun", "ehghefkfkk"],
      "expected": 8
    },
    {
      "arguments": ["oegvgivfieigun", "ijaehebhdbabek"],
      "expected": 1
    },
    {
      "arguments": ["wqgiqvwswwhiwfvihw", "khbafaaikaebkiaahg"],
      "expected": 15
    },
    {
      "arguments": ["zmpxe", "cfikd"],
      "expected": 0
    },
    {
      "arguments": ["svgxxaagjrjaee", "ifccaafgbgahhe"],
      "expected": 13
    },
    {
      "arguments": ["lyspsppgpvfaiypslavf", "jbbebkiagfbjhakihfjb"],
      "expected": 16
    },
    {
      "arguments": ["vvvhfogvfhkhmlvfvfg", "hiaaabhciahbfbjgaha"],
      "expected": 2
    },
    {
      "arguments": ["ij", "ij"],
      "expected": 0
    }
  ],
  "asserts_examples": [],
  "comment": null,
  "description_en": "A string $S$ (where $|S| ≤ 20$) was cyclically shifted $K$ characters to the left (for example, $\\text{abcde}$ will transform into $\\text{cdeab}$ when shifted by $K=2$), where $K$ could be any non-negative integer. Then a substitution cipher was applied: each letter was replaced with another letter such that the same letters were replaced with the same letters, and different letters were replaced with different letters (a bijective mapping). For example, $\\text{abac}$ could transform into $\\text{kmkn}$, but it could not transform into $\\text{kkkn}$ (non-injective) or $\\text{kmln}$ (non-consistent mapping). Determine the minimum shift value at which string $T$ could be obtained from $S$ using this substitution, or return $-1$ if it is impossible to obtain $T$ from $S$ using any combination of shifting and substitution.",
  "description_ru": "Строку $S$ (где $|S| ≤ 20$) циклически сдвинули на $K$ символов влево (например, $\\text{abcde}$ при сдвиге на $K=2$ превратится в $\\text{cdeab}$), $K$ могло быть любым. Затем к ней применили шифр замены: каждую букву заменили на другую так, что одинаковые буквы превратились в одинаковые, а разные - в разные (биективное отображение). Например, $\\text{abac}$ могло превратиться в $\\text{kmkn}$, но не могло в $\\text{kkkn}$ (не инъективно) или $\\text{kmln}$ (несогласованное отображение). Определите, минимальный сдвиг, при котором из $S$ могла получиться строка $T$ с помощью замены или верните $-1$, если получить $T$ из $S$ с помощью сдвига и замены невозможно.",
  "examples": "```\nsolution(\"abac\", \"mknk\") == 1\nsolution(\"abac\", \"kmkn\") == 0\nsolution(\"abac\", \"kkkn\") == -1\n```",
  "generator_lang": "js",
  "input_signature": [
    {
      "argument_name": "s",
      "type": {
        "name": "string"
      }
    },
    {
      "argument_name": "t",
      "type": {
        "name": "string"
      }
    }
  ],
  "level": "medium",
  "time_to_solve_sec_comment": "",
  "time_to_solve_sec": 2000,
  "name": "Сдвиг_и_замена",
  "origin": "user",
  "output_signature": {
    "type": {
      "name": "integer"
    }
  },
  "solution": "def solution(s : str, t : str) -> int:\n    s, t = t, s\n    if len(s) != len(t):\n        return -1\n        \n    def check(s, t):\n        if len(s) != len(t):\n            return False\n        mapping = {}\n        used = set()\n        for i in range(len(s)):\n            if s[i] in mapping:\n                if mapping[s[i]] != t[i]:\n                    return False\n            else:\n                if t[i] in used:\n                    return False\n                mapping[s[i]] = t[i]\n                used.add(t[i])\n        return True\n    \n    for i in range(len(s)):\n        if check(s, t):\n            return i\n        # Cyclically shift t to the right (which is equivalent to shifting s to the left)\n        t = t[-1] + t[:-1]\n    return -1\n",
  "tags": [],
  "visibility": "public"
}
