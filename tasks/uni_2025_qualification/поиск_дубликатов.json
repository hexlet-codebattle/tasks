{
  "asserts": [
    {"arguments": [["buy milk", "buy bread", "buy cheese"]], "expected": [["buy milk", "buy bread", "buy cheese"]]},
    {"arguments": [["call mom"]], "expected": []},
    {"arguments": [["Buy Milk!", "buy bread."]], "expected": [["Buy Milk!", "buy bread."]]},
    {"arguments": [["read a book", "write a book review", "buy a new book"]], "expected": [["read a book", "write a book review", "buy a new book"]]},
    {"arguments": [["do homework", "check homework", "send homework"]], "expected": [["do homework", "check homework", "send homework"]]},
    {"arguments": [["call mom", "call dad", "call grandma"]], "expected": [["call mom", "call dad", "call grandma"]]},
    {"arguments": [["go shopping", "buy groceries", "make a grocery list"]], "expected": []},
    {"arguments": [["sign up for gym", "go to gym", "buy gym membership"]], "expected": [["sign up for gym", "go to gym", "buy gym membership"]]},
    {"arguments": [["watch a movie", "write a movie review", "buy cinema ticket"]], "expected": [["watch a movie", "write a movie review"]]},
    {"arguments": [["do exercise", "go jogging", "do yoga"]], "expected": [["do exercise", "do yoga"]]},
    {"arguments": [["buy train ticket", "buy bus ticket", "buy plane ticket"]], "expected": [["buy train ticket", "buy bus ticket", "buy plane ticket"]]},
    {"arguments": [["clean the house", "tidy up toys", "dust the shelves"]], "expected": [["clean the house", "dust the shelves"]]},
    {"arguments": [["wash the car", "fuel the car", "change car oil"]], "expected": [["wash the car", "fuel the car", "change car oil"]]},
    {"arguments": [["visit dentist", "call dentist", "buy toothpaste"]], "expected": [["visit dentist", "call dentist"]]},
    {"arguments": [["make a presentation", "send presentation", "show presentation"]], "expected": [["make a presentation", "send presentation", "show presentation"]]},
    {"arguments": [["buy a gift", "wrap a gift", "send a gift"]], "expected": [["buy a gift", "wrap a gift", "send a gift"]]},
    {"arguments": [["take a photo", "send a photo", "print a photo"]], "expected": [["take a photo", "send a photo", "print a photo"]]},
    {"arguments": [["sign up for courses", "attend courses", "pay for courses"]], "expected": [["sign up for courses", "attend courses", "pay for courses"]]},
    {"arguments": [["buy vegetables", "buy fruits", "make a salad"]], "expected": [["buy vegetables", "buy fruits"]]},
    {"arguments": [["walk the dog", "feed the dog", "wash the dog"]], "expected": [["walk the dog", "feed the dog", "wash the dog"]]},
    {"arguments": [["place an order", "pay for order", "track order"]], "expected": [["place an order", "pay for order", "track order"]]},
    {"arguments": [["read an article", "write an article", "publish an article"]], "expected": [["read an article", "write an article", "publish an article"]]},
    {"arguments": [["buy laptop", "set up laptop", "install software on laptop"]], "expected": [["buy laptop", "set up laptop", "install software on laptop"]]},
    {"arguments": [["submit report", "check report", "send report"]], "expected": [["submit report", "check report", "send report"]]},
    {"arguments": [["buy concert ticket", "go to concert", "write concert review"]], "expected": [["buy concert ticket", "go to concert", "write concert review"]]},
    {"arguments": [["do renovation", "buy renovation materials", "clean after renovation"]], "expected": [["do renovation", "buy renovation materials", "clean after renovation"]]},
    {"arguments": [["sign up for manicure", "do manicure", "buy nail polish"]], "expected": [["sign up for manicure", "do manicure"]]},
    {"arguments": [["buy cat food", "wash the cat", "play with the cat"]], "expected": [["buy cat food", "wash the cat", "play with the cat"]]},
    {"arguments": [["make a translation", "send translation", "check translation"]], "expected": [["make a translation", "send translation", "check translation"]]},
    {"arguments": [["buy flowers", "water flowers", "give flowers"]], "expected": [["buy flowers", "water flowers", "give flowers"]]},
    {"arguments": [["a"]], "expected": []},
    {"arguments": [["a", "b"]], "expected": []},
    {"arguments": [["a b", "b c", "c d", "d e"]], "expected": [["a b", "b c"], ["b c", "c d"], ["c d", "d e"]]},
    {"arguments": [["one two", "two three", "three four", "four one"]], "expected": [["one two", "two three"], ["one two", "four one"], ["two three", "three four"], ["three four", "four one"]]},
    {"arguments": [["repeat repeat", "repeat repeat", "repeat repeat"]], "expected": [["repeat repeat", "repeat repeat", "repeat repeat"]]},
    {"arguments": [["task 1", "task 2", "task 3"]], "expected": [["task 1", "task 2", "task 3"]]},
    {"arguments": [["alpha beta", "beta gamma", "gamma delta", "delta alpha"]], "expected": [["alpha beta", "beta gamma"], ["alpha beta", "delta alpha"], ["beta gamma", "gamma delta"], ["gamma delta", "delta alpha"]]},
    {"arguments": [["apple pie", "apple juice", "orange juice"]], "expected": [["apple pie", "apple juice"], ["apple juice", "orange juice"]]},
    {"arguments": [["long task with many words", "another long task with many words", "completely different"]], "expected": [["long task with many words", "another long task with many words"]]},
    {"arguments": [["Task!", "task.", "TASK?"]], "expected": [["Task!", "task.", "TASK?"]]},
    {"arguments": [["123 buy", "buy 456", "789"]], "expected": [["123 buy", "buy 456"]]},
    {"arguments": [["one, two", "two; three", "three: four"]], "expected": [["one, two", "two; three"], ["two; three", "three: four"]]},
    {"arguments": [["repeat", "repeat", "unique"]], "expected": [["repeat", "repeat"]]},
    {"arguments": [["A b", "a B", "b a"]], "expected": [["A b", "a B", "b a"]]},
    {"arguments": [["first", "second", "third"]], "expected": []},
    {"arguments": [["one two three", "three four five", "five six seven"]], "expected": [["one two three", "three four five"], ["three four five", "five six seven"]]},
    {"arguments": [["unique task one", "unique task two", "unique task three"]], "expected": [["unique task one", "unique task two", "unique task three"]]},
    {"arguments": [["same", "same", "same"]], "expected": [["same", "same", "same"]]},
    {"arguments": [["no group here", "absolutely different", "nothing matches"]], "expected": []}
  ],
  "asserts_examples": [],
  "comment": null,
  "description_en": "You have a non-empty list of tasks (strings). It's guaranteed that each task contains at least one word. You need to group similar tasks. Tasks are considered similar if they share at least one common word (a sequence of letters or digits, ignoring case and punctuation). A group is defined as a set of 2 or more tasks where **each** task is directly similar to **every other** task within that set (i.e., they form a clique). The goal is to find all such **maximal** cliques (groups). The output should be a list of these maximal groups. The result must be sorted in two ways: 1. Tasks within each group must maintain their original relative order from the input list. 2. The list of groups itself must be sorted based on the original indices of the tasks they contain, compared lexicographically (e.g., group [task at index 1, task at index 5] comes before [task at index 2, task at index 3]).",
  "description_ru": "У вас есть непустой список задач. Гарантируется, что каждая задача содержит хотя бы одно слово. Необходимо сгруппировать похожие задачи. Задачи считаются похожими, если они содержат хотя бы одно общее слово (последовательность букв, без учета регистра и пунктуации). Группа — это набор из 2 или более задач, где **каждая** задача напрямую похожа на **каждую другую** задачу в этом же наборе. На выходе нужно вернуть список всех максимальных групп такого типа. Результат должен быть отсортирован: задачи внутри каждой группы сохраняют порядок из входного списка. Сам список групп сортируется путём последовательного сравнения исходных индексов задач в каждой группе.",
  "examples": "```\nsolution(['купить молоко',\n        'приобрести молоко',\n        'купить хлеб',\n        'достать молоко']) == \n[\n  ['купить молоко', 'приобрести молоко', 'достать молоко'],\n  ['купить молоко', 'купить хлеб']\n]\n```",
  "generator_lang": "js",
  "input_signature": [
    {
      "argument_name": "tasks",
      "type": {
        "name": "array",
        "nested": {
          "name": "string"
        }
      }
    }
  ],
  "level": "easy",
  "time_to_solve_sec_comment": "15 * 60 = 900 - это 15 минут",
  "time_to_solve_sec": 900,
  "name": "Поиск дубликатов",
  "origin": "user",
  "output_signature": {
    "type": {
      "name": "array",
      "nested": {
        "name": "array",
        "nested": {
          "name": "string"
        }
      }
    }
  },
  "tags": [],
  "visibility": "public",
  "solution": "import re\nfrom collections import defaultdict\n\ndef get_words(task):\n    # Находим последовательности букв (кириллица/латиница) или цифр в строке, приведенной к нижнему регистру\n    words = re.findall(r'[a-zа-яё0-9]+', task.lower())\n    return set(words)\n\ndef solution(tasks):\n    n = len(tasks)\n    if n < 2:\n        return []\n\n    task_data = []\n    # Предварительно вычисляем набор слов для каждой задачи, сохраняя исходный индекс\n    for i, task in enumerate(tasks):\n        words = get_words(task)\n        task_data.append({\"index\": i, \"words\": words})\n\n    # Строим список смежности (отображение исходного индекса в список схожих исходных индексов)\n    adj = defaultdict(list)\n    active_indices = set() # Отслеживаем индексы задач, в которых действительно есть слова\n    for i in range(n):\n        # Пропускаем задачи без слов (хотя по условию таких быть не должно)\n        if not task_data[i][\"words\"]: continue\n        active_indices.add(i)\n        for j in range(i + 1, n):\n             if not task_data[j][\"words\"]: continue\n             # Проверяем пересечение множеств слов\n             if task_data[i][\"words\"].intersection(task_data[j][\"words\"]):\n                adj[task_data[i][\"index\"]].append(task_data[j][\"index\"])\n                adj[task_data[j][\"index\"]].append(task_data[i][\"index\"])\n\n    maximal_cliques_indices = [] # Хранит клики как списки исходных индексов\n\n    # Алгоритм Брона-Кербоша (базовая версия без выбора опорного элемента)\n    def find_cliques(potential_clique, candidates, excluded):\n        nonlocal maximal_cliques_indices\n\n        # Если кандидатов и исключенных нет, найдена максимальная клика\n        if not candidates and not excluded:\n            # Сохраняем клику, если в ней 2 или более задачи\n            if len(potential_clique) >= 2:\n                 # Сохраняем как отсортированный список исходных индексов\n                 maximal_cliques_indices.append(sorted(list(potential_clique)))\n            return\n\n        # Итерируем по копии кандидатов, т.к. множество изменяется в рекурсии\n        pivot_candidates = list(candidates)\n        for v in pivot_candidates:\n            # Соседи v - это индексы задач, схожих с задачей v\n            neighbors_v = set(adj[v])\n            find_cliques(\n                potential_clique | {v},     # Добавляем v к текущей клике\n                candidates & neighbors_v,   # Новые кандидаты - общие соседи\n                excluded & neighbors_v      # Новые исключенные - общие соседи\n            )\n            # Шаг назад: перемещаем v из кандидатов в исключенные\n            candidates.remove(v)\n            excluded.add(v)\n\n    # Начальный вызов с активными индексами\n    find_cliques(set(), active_indices, set())\n\n    # Удаляем дубликаты клик (один и тот же набор индексов, найденный разными путями)\n    # Преобразуем список списков в множество кортежей для уникальности\n    unique_cliques_set = set(tuple(clique) for clique in maximal_cliques_indices)\n\n    # Преобразуем обратно в список списков и сортируем клики лексикографически\n    # Это гарантирует правильную сортировку итогового списка групп\n    sorted_unique_cliques = sorted([list(clique_tuple) for clique_tuple in unique_cliques_set])\n\n    # Отображаем отсортированные индексы обратно в исходные задачи\n    result_groups = []\n    task_map = {i: task for i, task in enumerate(tasks)}\n    for indices_clique in sorted_unique_cliques:\n        # Индексы в indices_clique уже отсортированы\n        group = [task_map[idx] for idx in indices_clique]\n        result_groups.append(group)\n\n    return result_groups"
}
